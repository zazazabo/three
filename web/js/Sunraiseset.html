<HTML>
<HEAD>
<TITLE>日出/日没时间计算程序</TITLE>

<SCRIPT LANGUAGE="JavaScript">

//***********************************************************************/
//*	DATA STRUCTURES                                                     */  
//* Based on the NOAA imporved JAVAscript             									*/
//***********************************************************************/

	function month(name, numdays, abbr) 
	{
		this.name = name;
		this.numdays = numdays;
		this.abbr = abbr;
	}

//*********************************************************************/

	function ans(daySave,value)
	{
		this.daySave = daySave;
		this.value = value;
	}

//*********************************************************************/

	function city(name, lat, lng, zoneHr) 
	{
		this.name = name;
		this.lat = lat;
		this.lng = lng;
		this.zoneHr = zoneHr;
	}


//***********************************************************************/
//*选择框数据                                               						*/
//***********************************************************************/

	var monthList = new Array();	//	list of months and days for non-leap year
	var i = 0;
	monthList[i++] = new month("一月", 31, "Jan");
	monthList[i++] = new month("二月", 28, "Feb");
	monthList[i++] = new month("三月", 31, "Mar");
	monthList[i++] = new month("四月", 30, "Apr");
	monthList[i++] = new month("五月", 31, "May");
	monthList[i++] = new month("六月", 30, "Jun");
	monthList[i++] = new month("七月", 31, "Jul");
	monthList[i++] = new month("八月", 31, "Aug");
	monthList[i++] = new month("九月", 30, "Sep");
	monthList[i++] = new month("十月", 31, "Oct");
	monthList[i++] = new month("十一月", 30, "Nov");
	monthList[i++] = new month("十二月", 31, "Dec");

//*********************************************************************/

	var YesNo = new Array();	//夏令时选项	
	i=0;
	YesNo[i++] = new ans("否",0);
	YesNo[i++] = new ans("是",60);

//*********************************************************************/

	var City = new Array();

	j = 0;
	City[j++] = new city("输入经纬度 -->",0,0,0);
	City[j++] = new city("",0,0,0);
	City[j++] = new city("中国城市",0,0,0);
	City[j++] = new city("北京, 中国", 39.9167, -116.4167,-8); 
	City[j++] = new city("北京2, 中国", 39.9000,-116.4667 ,-8);
	City[j++] = new city("天津, 中国", 39.1667,-117.1667  ,-8);
	City[j++] = new city("石家庄, 中国", 38.0500,-114.4333  ,-8);
	City[j++] = new city("保定, 中国", 38.8833,-115.4667  ,-8);
	City[j++] = new city("唐山, 中国", 39.6167,-118.1500  ,-8);
	City[j++] = new city("秦皇岛, 中国", 39.9000,-119.6167  ,-8);
	City[j++] = new city("张家口, 中国", 40.8500,-114.9167  ,-8);
	City[j++] = new city("承德, 中国", 40.9833,-117.8667  ,-8);
	City[j++] = new city("太原, 中国", 37.8500,-112.5500  ,-8);
	City[j++] = new city("大同, 中国", 40.1167,-113.2167  ,-8);
	City[j++] = new city("临汾, 中国", 36.0833,-111.5167  ,-8);
	City[j++] = new city("长治, 中国", 36.0833,-113.2167  ,-8);
	City[j++] = new city("呼和浩特, 中国", 40.8000,-111.6333  ,-8);
	City[j++] = new city("包头, 中国", 40.5833,-110.0000  ,-8);
	City[j++] = new city("海拉尔, 中国", 49.2333,-119.7167  ,-8);
	City[j++] = new city("沈阳, 中国", 41.8000,-123.3833  ,-8);
	City[j++] = new city("大连, 中国", 38.9000,-121.6333  ,-8);
	City[j++] = new city("鞍山, 中国", 41.0667,-123.0000  ,-8);
	City[j++] = new city("锦州, 中国", 41.1500,-121.1500  ,-8);
	City[j++] = new city("长春, 中国", 43.9167,-125.3000  ,-8);
	City[j++] = new city("吉林, 中国", 43.8000,-126.6000  ,-8);
	City[j++] = new city("哈尔滨, 中国", 45.7500,-126.6333  ,-8);
	City[j++] = new city("齐齐哈尔,中国", 47.3667,-123.9167  ,-8);
	City[j++] = new city("牡丹江,中国", 44.5833,129.6000  ,-8);
	City[j++] = new city("上海, 中国", 31.2000,-121.4333  ,-8);
	City[j++] = new city("南京, 中国", 32.0500,-118.7667  ,-8);
	City[j++] = new city("无锡, 中国", 31.5833,-120.3000  ,-8);
	City[j++] = new city("苏州, 中国", 31.3333,-120.6500  ,-8);
	City[j++] = new city("徐州, 中国", 34.2667,-117.2000  ,-8);
	City[j++] = new city("杭州, 中国", 30.2500,-120.1667  ,-8);
	City[j++] = new city("宁波, 中国", 29.8833,-121.5667  ,-8);
	City[j++] = new city("温州, 中国", 28.0000,-120.6333  ,-8);
	City[j++] = new city("金华, 中国", 29.1667,-119.8167  ,-8);
	City[j++] = new city("合肥, 中国", 31.8500,-117.2667  ,-8);
	City[j++] = new city("芜湖, 中国", 31.3500,-118.3333  ,-8);
	City[j++] = new city("安庆, 中国", 30.5333,-117.0333  ,-8);
	City[j++] = new city("福州, 中国", 26.0333,-119.3167  ,-8);
	City[j++] = new city("厦门, 中国", 24.4333,-118.0667  ,-8);
	City[j++] = new city("泉州, 中国", 24.9000,-118.6167  ,-8);
	City[j++] = new city("南昌, 中国", 28.6833,-115.8833  ,-8);
	City[j++] = new city("九江, 中国", 29.7167,-115.9833  ,-8);
	City[j++] = new city("赣州, 中国", 25.8500,-114.9333  ,-8);
	City[j++] = new city("济南, 中国", 36.6667,-117.0333  ,-8);
	City[j++] = new city("烟台, 中国", 37.5500,-121.3333  ,-8);
	City[j++] = new city("青岛, 中国", 36.0667,-120.3167  ,-8);
	City[j++] = new city("郑州, 中国", 34.7333,-113.7000  ,-8);
	City[j++] = new city("开封, 中国", 34.8667,-114.3833  ,-8);
	City[j++] = new city("洛阳, 中国", 34.7167,-112.4333  ,-8);
	City[j++] = new city("许昌, 中国", 34.0000,-113.8000  ,-8);
	City[j++] = new city("新乡, 中国", 35.3000,-113.9000  ,-8);
	City[j++] = new city("武汉, 中国", 30.6167,-114.3333  ,-8);
	City[j++] = new city("宜昌, 中国", 30.7000,-111.2500  ,-8);
	City[j++] = new city("沙市, 中国", 30.2667,-112.2833  ,-8);
	City[j++] = new city("长沙, 中国", 28.2000,-112.9167  ,-8);
	City[j++] = new city("衡阳, 中国", 26.9167,-112.5667  ,-8);
	City[j++] = new city("湘潭, 中国", 27.9000,-112.8500  ,-8);
	City[j++] = new city("常德, 中国", 29.0000,-111.6500  ,-8);
	City[j++] = new city("广州, 中国", 23.1667,-113.3000  ,-8);
	City[j++] = new city("汕头, 中国", 23.3500,-116.6667  ,-8);
	City[j++] = new city("韶关, 中国", 24.8000,-113.5500  ,-8);
	City[j++] = new city("海口, 中国", 20.0500,-110.1667  ,-8);
	City[j++] = new city("南宁, 中国", 22.7833,-108.3500  ,-8);
	City[j++] = new city("桂林, 中国", 25.3000,-110.1667  ,-8);
	City[j++] = new city("柳州, 中国", 24.3333,-109.3167  ,-8);
	City[j++] = new city("悟州, 中国", 23.4667,-111.3000  ,-8);
	City[j++] = new city("成都, 中国", 30.6500,-104.0667  ,-8);
	City[j++] = new city("重庆, 中国", 29.5500,-106.5500  ,-8);
	City[j++] = new city("内江, 中国", 29.5833,-105.0500  ,-8);
	City[j++] = new city("泸州, 中国", 28.9000,-105.4500  ,-8);
	City[j++] = new city("万县, 中国", 30.8000,-108.3667  ,-8);
	City[j++] = new city("贵阳, 中国", 26.5667,-106.7167  ,-8);
	City[j++] = new city("遵义, 中国", 27.7500,-106.8833  ,-8);
	City[j++] = new city("昆明, 中国", 25.0500,-102.7000  ,-8);
	City[j++] = new city("拉萨, 中国", 29.6500, -91.0333  ,-8);
	City[j++] = new city("日喀则, 中国", 29.2667, -88.8167  ,-8);
	City[j++] = new city("西安, 中国", 34.2500,-108.9167  ,-8);
	City[j++] = new city("宝鸡, 中国", 34.3500,-107.1500  ,-8);
	City[j++] = new city("延安, 中国", 36.5833,-109.4333  ,-8);
	City[j++] = new city("兰州, 中国", 36.0500,-103.8333  ,-8);
	City[j++] = new city("天水, 中国", 34.5833,-105.5500  ,-8);
	City[j++] = new city("酒泉, 中国", 39.7333,-98.5000  ,-8);
	City[j++] = new city("西宁, 中国", 36.6167,-101.8167  ,-8);
	City[j++] = new city("喀什, 中国", 39.4500,-75.9833   ,-8);
	City[j++] = new city("和田, 中国", 37.1167,-79.9167   ,-8);
	City[j++] = new city("台北, 中国", 25.0333,-121.5167  ,-8);
	City[j++] = new city("香港, 中国", 22.25,-114.1667, -8);
	City[j++] = new city("",0,0,0);	
	City[j++] = new city("US CITIES",0,0,0);
	City[j++] = new city("Albuquerque, NM", 35.0833,106.65,7);
	City[j++] = new city("Anchorage, AK", 61.217, 149.90,9);
	City[j++] = new city("Atlanta, GA", 33.733, 84.383, 5);
	City[j++] = new city("Austin, TX", 30.283, 97.733, 6);
	City[j++] = new city("Birmingham, AL", 33.521, 86.8025, 6);
	City[j++] = new city("Bismarck, ND", 46.817, 100.783, 6);
	City[j++] = new city("Boston, MA", 42.35, 71.05, 5);
	City[j++] = new city("Boulder, CO", 40.125, 105.237, 7);
	City[j++] = new city("Chicago, IL", 41.85,87.65,6);
	City[j++] = new city("Dallas, TX", 32.46, 96.47,6);
	City[j++] = new city("Denver, CO", 39.733, 104.983, 7);
	City[j++] = new city("Detroit, MI", 42.333, 83.05, 5);
	City[j++] = new city("Honolulu, HI", 21.30, 157.85, 10);
	City[j++] = new city("Houston, TX", 29.75, 95.35, 6);
	City[j++] = new city("Indianapolis, IN", 39.767, 86.15, 5);
	City[j++] = new city("Jackson, MS", 32.283, 90.183, 6);
	City[j++] = new city("Kansas City, MO", 39.083, 94.567,6);
	City[j++] = new city("Los Angeles, CA",34.05,118.233,8);
	City[j++] = new city("Menomonee Falls, WI",43.11,88.10,6);
	City[j++] = new city("Miami, FL", 25.767, 80.183,5);
	City[j++] = new city("Minneapolis, MN", 44.967, 93.25, 6);
	City[j++] = new city("New Orleans, LA", 29.95, 90.067, 6);
	City[j++] = new city("New York City, NY", 40.7167, 74.0167, 5);
	City[j++] = new city("Oklahoma City, OK", 35.483, 97.533,6);
	City[j++] = new city("Philadelphia, PA", 39.95, 75.15, 5);
	City[j++] = new city("Phoenix, AZ",33.433,112.067,7);
	City[j++] = new city("Pittsburgh, PA",40.433,79.9833,5);
	City[j++] = new city("Portland, ME", 43.666, 70.283, 5);
	City[j++] = new city("Portland, OR", 45.517, 122.65, 8);
	City[j++] = new city("Raleigh, NC", 35.783, 78.65, 5);
	City[j++] = new city("Richmond, VA", 37.5667, 77.450, 5);
	City[j++] = new city("Saint Louis, MO", 38.6167,90.1833,6);
	City[j++] = new city("San Diego, CA", 32.7667, 117.2167, 8);
	City[j++] = new city("San Francisco, CA",37.7667,122.4167,8);
	City[j++] = new city("Seattle, WA",47.60,122.3167,8);
	City[j++] = new city("Washington DC", 38.8833, 77.0333,5);
	City[j++] = new city("",0,0,0);
	City[j++] = new city("WORLD CITIES",0,0,0);
	City[j++] = new city("Beijing, China",39.9167, -116.4167,-8);
	City[j++] = new city("Berlin, Germany",52.33, -13.30, -1);
	City[j++] = new city("Bombay, India", 18.9333, -72.8333, -5.5);
	City[j++] = new city("Buenos Aires, Argentina", -34.60,58.45,3);
	City[j++] = new city("Cairo, Egypt", 30.10,-31.3667,-2);
	City[j++] = new city("Cape Town, South Africa",-33.9167,-18.3667,-2);
	City[j++] = new city("Caracas, Venezuela", 10.50,66.9333,4);
	City[j++] = new city("Helsinki, Finland", 60.1667, -24.9667,-2);
	City[j++] = new city("Hong Kong, China", 22.25,-114.1667, -8);
	City[j++] = new city("Jerusalem, Israel", 31.7833, -35.2333, -2);
	City[j++] = new city("London, England", 51.50, 0.1667,0);
	City[j++] = new city("Mexico City, Mexico", 19.4,99.15,6);
	City[j++] = new city("Moscow, Russia", 55.75, -37.5833, -3);
	City[j++] = new city("New Delhi, India",28.6, -77.2, -5.5);
	City[j++] = new city("Ottawa, Canada", 45.41667,75.7,5);
	City[j++] = new city("Paris, France", 48.8667, -2.667, -1);
	City[j++] = new city("Rio de Janeiro, Brazil",-22.90,43.2333,3);
	City[j++] = new city("Riyadh, Saudi Arabia", 24.633, -46.71667, -3);
	City[j++] = new city("Rome, Italy",41.90, -12.4833,-1);
	City[j++] = new city("Sydney, Australia",-33.8667,-151.2167,-10);
	City[j++] = new city("Tokyo, Japan", 35.70, -139.7667, -9); 
	City[j++] = new city("Zurich, Switzerland", 47.3833, -8.5333,-1);
	City[j++] = new city("",0,0,0);
	City[j++] = new city("SURFRAD NETWORK",0,0,0);
	City[j++] = new city("Goodwin Creek, MS",34.2544444,89.8738888, 6);
	City[j++] = new city("Fort Peck, MT",48.310555,105.1025, 7);
	City[j++] = new city("Bondville, IL",40.055277,88.371944, 6);
	City[j++] = new city("Table Mountain, CO",40.125,105.23694, 7);
	City[j++] = new city("Desert Rock, NV",36.626, 116.018, 8);
	City[j++] = new city("Penn State, PA", 40.72, 77.93, 5);
	City[j++] = new city("Canaan Valley, WV", 39.1, 79.4, 5);
	City[j++] = new city("Sioux Falls, SD", 43.733, 96.6233, 6);
	City[j++] = new city("",0,0,0);
	City[j++] = new city("ARM/CART NETWORK",0,0,0);
	City[j++] = new city("Atqasuk, AK", 70.47215, 157.4078, 9);
	City[j++] = new city("Barrow, AK", 71.30,156.683, 9);
	City[j++] = new city("Manus Island, PNG", -2.06, -147.425,-10);
	City[j++] = new city("Nauru Island", -0.52, -166.92, -12);
	City[j++] = new city("Darwin, Australia", -12.425, -130.891, -9.5);
	City[j++] = new city("SGP Central Facility", 36.6167, 97.5, 6);
	City[j++] = new city("",0,0,0);
	City[j++] = new city("ISIS NETWORK",0,0,0);
	City[j++] = new city("Albuquerque, NM", 35.04, 106.62,7);
	City[j++] = new city("Bismarck, ND", 46.77, 100.77,6);
	City[j++] = new city("Hanford, CA", 36.31, 119.63,8);
	City[j++] = new city("Madison, WI", 43.13, 89.33,6);	
	City[j++] = new city("Oak Ridge, TN", 35.96, 84.37,5);
	City[j++] = new city("Salt Lake City, UT", 40.77,111.97,7);
	City[j++] = new city("Seattle, WA", 47.68, 122.25,8);
	City[j++] = new city("Sterling, VA", 38.98, 77.47,5);
	City[j++] = new city("Tallahassee, FL", 30.38, 84.37,5);

//*********************************************************************/

</SCRIPT>
</HEAD>

<BODY BACKGROUND="./sunrise4.jpg" bgcolor="#99CCFF">
<CENTER>
<TABLE BORDER=0 CELLPADDING=4>
<TR><TD>                    
<A HREF="http://www.cern.ac.cn/"><IMG SRC="./rigui2.jpg" ALT="IGSNRR" BORDER=0></A>
</TD>
<TD>
<CENTER>
<FONT SIZE="3"><B><A HREF="http://linzhonghui.googlepages.com/">龙门山人</A></B></FONT><BR>
<FONT SIZE="6"><B>日出/日没时间计算</B></FONT>
</CENTER>
</TD>
<TD>
<CENTER>
<A HREF="http://linzhonghui.google.com/"><IMG SRC=".cern_top-2.jpg" ALT="longmenshanren" BORDER=0></A><BR>
</CENTER>
</TD>
</TR>
</TABLE>
</CENTER>
<HR>

<SCRIPT LANGUAGE="JavaScript">

//*********************************************************************/


	function setLatLong(f, index)
	{
		// Decimal degrees are passed in the array.  Temporarily store these 
		// degs in lat and lon deg and have convLatLong modify them.
		// 将数组中十进制度数传递到指定的窗体文本框。
		// 临时存储这些度数为经度和纬度，可以通过convLatLong函数修改他们。

		f["latDeg"].value = City[index].lat;
		f["lonDeg"].value = City[index].lng;
	
		// These are needed to prevent iterative adding of min and sec when 
		// set button is clicked.
		// 当按下Set按钮是必须确保重复的分钟和秒的添加。

		f["latMin"].value = 0;
		f["latSec"].value = 0;
		f["lonMin"].value = 0;
		f["lonSec"].value = 0;
		
		//call convLatLong to convert decimal degrees into table form.
		// 调用covLatLong将十进制度数放入表单中。

		convLatLong(f);

		//Local time zone value set in table
		// 设置本地时区

		f["hrsToGMT"].value =  City[index].zoneHr;
	}


//*********************************************************************/

// isLeapYear returns 1 if the 4-digit yr is a leap year, 0 if it is not

	// 如果指定的年份(用4位阿拉伯数字表示)是闰年则返回1；否则返回0。
	function isLeapYear(yr) 
	{
		return ((yr % 4 == 0 && yr % 100 != 0) || yr % 400 == 0);
	}


//*********************************************************************/

// isPosInteger returns false if the value is not a positive integer, true is
// returned otherwise.  The code is from taken from Danny Goodman's Javascript
// Handbook, p. 372.

	// 如果指定的值不是正正数则返回false；否则返回true。
	function isPosInteger(inputVal) 
	{
		inputStr = ("" + inputVal);
		for (var i = 0; i < inputStr.length; i++) {
			var oneChar = inputStr.charAt(i);
			if (oneChar < "0" || oneChar > "9")
				return false;
		}
		return true;
	}

//*********************************************************************/

	// 判断指定的数字是否为整数。
	function isInteger(inputVal) 
	{
		inputStr = "" + inputVal;
		if(inputStr == "NaN") return false;
		if(inputStr == "-NaN") return false;
		for (var i = 0; i < inputStr.length; i++) 
		{
			var oneChar = inputStr.charAt(i);
			if (i == 0 && (oneChar == "-" || oneChar == "+"))
			{
				continue;
			}
			if (oneChar < "0" || oneChar > "9")
			{
				return false;
			}
		}
		return true;
	}


//*********************************************************************/

	// 判断所指定的是否为数字。
	function isNumber(inputVal) 
	{
		var oneDecimal = false;
		var inputStr = "" + inputVal;
		for (var i = 0; i < inputStr.length; i++) 
		{
			var oneChar = inputStr.charAt(i);
			if (i == 0 && (oneChar == "-" || oneChar == "+"))
			{
				continue;
			}
			if (oneChar == "." && !oneDecimal) 
			{
				oneDecimal = true;
				continue;
			}
			if (oneChar < "0" || oneChar > "9")
			{
				return false;
			}
		}
		return true;
	}


//*********************************************************************/

// isValidInput makes sure valid input is entered before going ahead to 
// calculate the sunrise and sunset.  False is returned if an invalid entry 
// was made, true is the entry is valid.

	// 计算日出和日落之前确保输入是有效的。所有项都有效返回true；否则返回false。
	function isValidInput(f, index, latLongForm) 
	{
		if (f["day"].value == "") 
		{	//	see if the day field is empty
			alert("请先输入日期再计算.");
			return false;
		}
		else if (f["year"].value == "") 
		{	//	 see if the year field is empty
			alert("请先输入年份再计算.");
			return false;
		}
		else if (!isPosInteger(f["day"].value) || f["day"].value == 0)
		{
			alert("日期值必须为正.");
			return false;
		}
		else if (!isInteger(f["year"].value)) 
		{
			alert("年份必须是整数.");
			return false;
		}
		else if ( (f["year"].value < -1000) || (f["year"].value > 3000) )
		{
			alert("本算法在 -1000 ~ 3000年间适用.");
			return false;
		}


		//	For the non-二月 months see if the day entered is greater than
		//	the number of days in the selected month

		else if ((index != 1) && (f["day"].value > monthList[index].numdays)) 
		{
			alert("只有 " + monthList[index].numdays + " 天 " 
				+ monthList[index].name + ".");
			return false;
		}

		//	First see if the year entered is a leap year.  If so we have to make sure
		//	the days entered is <= 29.  If not a leap year we make sure that the days
		//	entered is <= 28.

		else if (index == 1) 
		{	//	 month selected is 二月 the screwball month
			if (isLeapYear(f["year"].value)) {	//	year entered is a leap year
				if (f["day"].value > (monthList[index].numdays + 1)) 
				{
					alert("There are only " + (monthList[index].numdays + 1) 
						+ " days in " + monthList[index].name + ".");
					return false;
				}
				else
					return true;
			}
			else 
			{	//	year entered is not a leap year
				if (f["day"].value > monthList[index].numdays) 
				{
					alert(monthList[index].name +"只有" +monthList[index].numdays 
						+ " 天" +"。");
					return false;
				}
				else
					return true;
			}
		}
		else 
			return true;	
	}

//*********************************************************************/

//convLatLong converts any type of lat/long input
//into  the table form and then handles bad input
//it is nested in the calcSun function.
	// 将输入的任意类型的经度纬度转换输入到表单中，并且处理无效的输入。
	// 嵌套在calcSun函数。
	function convLatLong(f)
	{
		if(f["latDeg"].value == "")
		{
			f["latDeg"].value = 0;
		}
		if(f["latMin"].value == "")
		{
			f["latMin"].value = 0;
		}
		if(f["latSec"].value == "")
		{
			f["latSec"].value = 0;
		}
		if(f["lonDeg"].value == "")
		{
			f["lonDeg"].value = 0;
		}
		if(f["lonMin"].value == "")
		{
			f["lonMin"].value = 0;
		}
		if(f["lonSec"].value == "")
		{
			f["lonSec"].value = 0;
		}

		var neg = 0;
		if(f["latDeg"].value.charAt(0) == '-') 
		{
			neg = 1;
		}

		if(neg != 1)
		{
			var latSeconds = (parseFloat(f["latDeg"].value))*3600 
				+ parseFloat(f["latMin"].value)*60 
				+ parseFloat(f["latSec"].value)*1;

			f["latDeg"].value = Math.floor(latSeconds/3600);
			f["latMin"].value = Math.floor((latSeconds
				- (parseFloat(f["latDeg"].value)*3600))/60);
			f["latSec"].value = Math.floor((latSeconds
				- (parseFloat(f["latDeg"].value)*3600) 
				- (parseFloat(f["latMin"].value)*60)) + 0.5);
		}
		else if(parseFloat(f["latDeg"].value) > -1)
		{
			var latSeconds = parseFloat(f["latDeg"].value)*3600 
				- parseFloat(f["latMin"].value)*60 
				- parseFloat(f["latSec"].value)*1;

			f["latDeg"].value = "-0";
			f["latMin"].value = Math.floor((-latSeconds)/60);
			f["latSec"].value = Math.floor( (-latSeconds 
				- (parseFloat(f["latMin"].value)*60)) + 0.5);

		}
		else
		{
			var latSeconds = parseFloat(f["latDeg"].value)*3600 
				- parseFloat(f["latMin"].value)*60 
				- parseFloat(f["latSec"].value)*1;

			f["latDeg"].value = Math.ceil(latSeconds/3600);
			f["latMin"].value = Math.floor((-latSeconds
				+ (parseFloat(f["latDeg"].value)*3600))/60);
			f["latSec"].value = Math.floor((-latSeconds
				+ (parseFloat(f["latDeg"].value)*3600) 
				- (parseFloat(f["latMin"].value)*60)) + 0.5);
		}

		neg = 0;
		if(f["lonDeg"].value.charAt(0) == '-') 
		{
			neg = 1;
		}

		if(neg != 1)
		{
			var lonSeconds = parseFloat(f["lonDeg"].value)*3600 
				+ parseFloat(f["lonMin"].value)*60 
				+ parseFloat(f["lonSec"].value)*1;
			f["lonDeg"].value = Math.floor(lonSeconds/3600);
			f["lonMin"].value = Math.floor((lonSeconds
				- (parseFloat(f["lonDeg"].value)*3600))/60);
			f["lonSec"].value = Math.floor((lonSeconds
				- (parseFloat(f["lonDeg"].value)*3600)
				- (parseFloat(f["lonMin"].value))*60) + 0.5);
		}
		else if(parseFloat(f["lonDeg"].value) > -1)
		{
			var lonSeconds = parseFloat(f["lonDeg"].value)*3600 
				- parseFloat(f["lonMin"].value)*60 
				- parseFloat(f["lonSec"].value)*1;

			f["lonDeg"].value = "-0";
			f["lonMin"].value = Math.floor((-lonSeconds)/60);
			f["lonSec"].value = Math.floor((-lonSeconds
				- (parseFloat(f["lonMin"].value)*60)) + 0.5);
		}
		else
		{
			var lonSeconds = parseFloat(f["lonDeg"].value)*3600 
				- parseFloat(f["lonMin"].value)*60 
				- parseFloat(f["lonSec"].value)*1;
			f["lonDeg"].value = Math.ceil(lonSeconds/3600);
			f["lonMin"].value = Math.floor((-lonSeconds
				+ (parseFloat(f["lonDeg"].value)*3600))/60);
			f["lonSec"].value = Math.floor((-lonSeconds
				+ (parseFloat(f["lonDeg"].value)*3600)
				- (parseFloat(f["lonMin"].value)*60)) + 0.5);
		}

		//Test for invalid lat/long input

		if(latSeconds > 324000)
		{
			alert("You have entered an invalid latitude.\n  Setting lat = 89.");
			f["latDeg"].value = 89;
			f["latMin"].value = 0;
			f["latSec"].value = 0;
		}
		if(latSeconds < -324000)
		{
			alert("You have entered an invalid latitude.\n  Setting lat = -89.");
			f["latDeg"].value = -89;
			f["latMin"].value = 0;
			f["latSec"].value = 0;
		}
		if(lonSeconds > 648000)
		{
			alert("You have entered an invalid longitude.\n Setting lon = 180.");
			f["lonDeg"].value = 180;
			f["lonMin"].value = 0;
			f["lonSec"].value = 0;
		}
		if(lonSeconds < -648000)
		{
			alert("You have entered an invalid longitude.\n Setting lon = -180.");
			f["lonDeg"].value = -180;
			f["lonMin"].value = 0;
			f["lonSec"].value =0;
		}

	}



//***********************************************************************/
//***********************************************************************/
//*												*/
//*This section contains subroutines used in calculating solar position */
//*												*/
//***********************************************************************/
//***********************************************************************/

// Convert radian angle to degrees

	// 将弧度转为度数。
	function radToDeg(angleRad) 
	{
		return (180.0 * angleRad / Math.PI);
	}

//*********************************************************************/

// Convert degree angle to radians

	// 将度数转换为弧度。
	function degToRad(angleDeg) 
	{
		return (Math.PI * angleDeg / 180.0);
	}

//*********************************************************************/


//***********************************************************************/
//* Name:    calcDayOfYear								*/
//* Type:    Function									*/
//* Purpose: Finds numerical day-of-year from mn, day and lp year info  */
//* Arguments:										*/
//*   month: 一月 = 1								*/
//*   day  : 1 - 31									*/
//*   lpyr : 1 if leap year, 0 if not						*/
//* Return value:										*/
//*   The numerical day of year							*/
//***********************************************************************/

	// 根据月份、天数和是否为闰年计算是否为闰年。
	function calcDayOfYear(mn, dy, lpyr) 
	{
		var k = (lpyr ? 1 : 2);
		var doy = Math.floor((275 * mn)/9) - k * Math.floor((mn + 9)/12) + dy -30;
		return doy;
	}


//***********************************************************************/
//* Name:    calcDayOfWeek								*/
//* Type:    Function									*/
//* Purpose: Derives weekday from Julian Day					*/
//* Arguments:										*/
//*   juld : Julian Day									*/
//* Return value:										*/
//*   String containing name of weekday						*/
//***********************************************************************/
	// 使用儒略日计算星期名称。
	function calcDayOfWeek(juld)
	{
		var A = (juld + 1.5) % 7;
		var DOW = (A==0)?"Sunday":(A==1)?"Monday":(A==2)?"Tuesday":(A==3)?"Wednesday":(A==4)?"Thursday":(A==5)?"Friday":"Saturday";
		return DOW;
	}


//***********************************************************************/
//* Name:    calcJD									*/
//* Type:    Function									*/
//* Purpose: Julian day from calendar day						*/
//* Arguments:										*/
//*   year : 4 digit year								*/
//*   month: 一月 = 1								*/
//*   day  : 1 - 31									*/
//* Return value:										*/
//*   The Julian day corresponding to the date					*/
//* Note:											*/
//*   Number is returned for start of day.  Fractional days should be	*/
//*   added later.									*/
//***********************************************************************/
	// 通过历日计算儒略日。
	function calcJD(year, month, day)
	{
		if (month <= 2) {
			year -= 1;
			month += 12;
		}
		var A = Math.floor(year/100);
		var B = 2 - A + Math.floor(A/4);

		var JD = Math.floor(365.25*(year + 4716)) + Math.floor(30.6001*(month+1)) + day + B - 1524.5;
		return JD;
	}



//***********************************************************************/
//* Name:    calcDateFromJD								*/
//* Type:    Function									*/
//* Purpose: Calendar date from Julian Day					*/
//* Arguments:										*/
//*   jd   : Julian Day									*/
//* Return value:										*/
//*   String date in the form DD-MONTHNAME-YYYY					*/
//* Note:											*/
//***********************************************************************/

	// 通过天略日计算日期。
	function calcDateFromJD(jd)
	{
		var z = Math.floor(jd + 0.5);
		var f = (jd + 0.5) - z;

		if (z < 2299161) {
			var A = z;
		} else {
			alpha = Math.floor((z - 1867216.25)/36524.25);
			var A = z + 1 + alpha - Math.floor(alpha/4);
		}

		var B = A + 1524;
		var C = Math.floor((B - 122.1)/365.25);
		var D = Math.floor(365.25 * C);
		var E = Math.floor((B - D)/30.6001);

		var day = B - D - Math.floor(30.6001 * E) + f;
		var month = (E < 14) ? E - 1 : E - 13;
		var year = (month > 2) ? C - 4716 : C - 4715;

		// alert ("date: " + day + "-" + monthList[month-1].name + "-" + year);
		return (day + "-" + monthList[month-1].name + "-" + year);
	}


//***********************************************************************/
//* Name:    calcDayFromJD								*/
//* Type:    Function									*/
//* Purpose: Calendar day (minus year) from Julian Day			*/
//* Arguments:										*/
//*   jd   : Julian Day									*/
//* Return value:										*/
//*   String date in the form DD-MONTH						*/
//***********************************************************************/
	// 根据儒略日计算月份日子。
	function calcDayFromJD(jd)
	{
		var z = Math.floor(jd + 0.5);
		var f = (jd + 0.5) - z;

		if (z < 2299161) {
			var A = z;
		} else {
			alpha = Math.floor((z - 1867216.25)/36524.25);
			var A = z + 1 + alpha - Math.floor(alpha/4);
		}

		var B = A + 1524;
		var C = Math.floor((B - 122.1)/365.25);
		var D = Math.floor(365.25 * C);
		var E = Math.floor((B - D)/30.6001);

		var day = B - D - Math.floor(30.6001 * E) + f;
		var month = (E < 14) ? E - 1 : E - 13;
		var year = (month > 2) ? C - 4716 : C - 4715;

		return ((day<10 ? "0" : "") + day + monthList[month-1].abbr);
	}


//***********************************************************************/
//* Name:    calcTimeJulianCent							*/
//* Type:    Function									*/
//* Purpose: convert Julian Day to centuries since J2000.0.			*/
//* Arguments:										*/
//*   jd : the Julian Day to convert						*/
//* Return value:										*/
//*   the T value corresponding to the Julian Day				*/
//***********************************************************************/

	// 转换儒略日为世纪。
	function calcTimeJulianCent(jd)
	{
		var T = (jd - 2451545.0)/36525.0;
		return T;
	}


//***********************************************************************/
//* Name:    calcJDFromJulianCent							*/
//* Type:    Function									*/
//* Purpose: convert centuries since J2000.0 to Julian Day.			*/
//* Arguments:										*/
//*   t : number of Julian centuries since J2000.0				*/
//* Return value:										*/
//*   the Julian Day corresponding to the t value				*/
//***********************************************************************/

	// 转换世纪为儒略日。
	function calcJDFromJulianCent(t)
	{
		var JD = t * 36525.0 + 2451545.0;
		return JD;
	}


//***********************************************************************/
//* Name:    calGeomMeanLongSun							*/
//* Type:    Function									*/
//* Purpose: calculate the Geometric Mean Longitude of the Sun		*/
//* Arguments:										*/
//*   t : number of Julian centuries since J2000.0				*/
//* Return value:										*/
//*   the Geometric Mean Longitude of the Sun in degrees			*/
//***********************************************************************/
	// 计算太阳的平黄经。
	function calcGeomMeanLongSun(t)
	{
		var L0 = 280.46646 + t * (36000.76983 + 0.0003032 * t);
		while(L0 > 360.0)
		{
			L0 -= 360.0;
		}
		while(L0 < 0.0)
		{
			L0 += 360.0;
		}
		return L0;		// in degrees
	}


//***********************************************************************/
//* Name:    calGeomAnomalySun							*/
//* Type:    Function									*/
//* Purpose: calculate the Geometric Mean Anomaly of the Sun		*/
//* Arguments:										*/
//*   t : number of Julian centuries since J2000.0				*/
//* Return value:										*/
//*   the Geometric Mean Anomaly of the Sun in degrees			*/
//***********************************************************************/

	// 计算太阳的平近点角。
	function calcGeomMeanAnomalySun(t)
	{
		var M = 357.52911 + t * (35999.05029 - 0.0001537 * t);
		return M;		// in degrees
	}

//***********************************************************************/
//* Name:    calcEccentricityEarthOrbit						*/
//* Type:    Function									*/
//* Purpose: calculate the eccentricity of earth's orbit			*/
//* Arguments:										*/
//*   t : number of Julian centuries since J2000.0				*/
//* Return value:										*/
//*   the unitless eccentricity							*/
//***********************************************************************/


	// 计算环地轨道的离心率。
	function calcEccentricityEarthOrbit(t)
	{
		var e = 0.016708634 - t * (0.000042037 + 0.0000001267 * t);
		return e;		// unitless
	}

//***********************************************************************/
//* Name:    calcSunEqOfCenter							*/
//* Type:    Function									*/
//* Purpose: calculate the equation of center for the sun			*/
//* Arguments:										*/
//*   t : number of Julian centuries since J2000.0				*/
//* Return value:										*/
//*   in degrees										*/
//***********************************************************************/

	// 计算太阳的中心差。
	function calcSunEqOfCenter(t)
	{
		var m = calcGeomMeanAnomalySun(t);

		var mrad = degToRad(m);
		var sinm = Math.sin(mrad);
		var sin2m = Math.sin(mrad+mrad);
		var sin3m = Math.sin(mrad+mrad+mrad);

		var C = sinm * (1.914602 - t * (0.004817 + 0.000014 * t)) + sin2m * (0.019993 - 0.000101 * t) + sin3m * 0.000289;
		return C;		// in degrees
	}

//***********************************************************************/
//* Name:    calcSunTrueLong								*/
//* Type:    Function									*/
//* Purpose: calculate the true longitude of the sun				*/
//* Arguments:										*/
//*   t : number of Julian centuries since J2000.0				*/
//* Return value:										*/
//*   sun's true longitude in degrees						*/
//***********************************************************************/

	// 计算太阳的真经度。
	function calcSunTrueLong(t)
	{
		var l0 = calcGeomMeanLongSun(t);
		var c = calcSunEqOfCenter(t);

		var O = l0 + c;
		return O;		// in degrees
	}

//***********************************************************************/
//* Name:    calcSunTrueAnomaly							*/
//* Type:    Function									*/
//* Purpose: calculate the true anamoly of the sun				*/
//* Arguments:										*/
//*   t : number of Julian centuries since J2000.0				*/
//* Return value:										*/
//*   sun's true anamoly in degrees							*/
//***********************************************************************/
	// 计算太阳的真近点角。
	function calcSunTrueAnomaly(t)
	{
		var m = calcGeomMeanAnomalySun(t);
		var c = calcSunEqOfCenter(t);

		var v = m + c;
		return v;		// in degrees
	}

//***********************************************************************/
//* Name:    calcSunRadVector								*/
//* Type:    Function									*/
//* Purpose: calculate the distance to the sun in AU				*/
//* Arguments:										*/
//*   t : number of Julian centuries since J2000.0				*/
//* Return value:										*/
//*   sun radius vector in AUs							*/
//***********************************************************************/
	// 计算太阳矢径。
	function calcSunRadVector(t)
	{
		var v = calcSunTrueAnomaly(t);
		var e = calcEccentricityEarthOrbit(t);
 
		var R = (1.000001018 * (1 - e * e)) / (1 + e * Math.cos(degToRad(v)));
		return R;		// in AUs
	}

//***********************************************************************/
//* Name:    calcSunApparentLong							*/
//* Type:    Function									*/
//* Purpose: calculate the apparent longitude of the sun			*/
//* Arguments:										*/
//*   t : number of Julian centuries since J2000.0				*/
//* Return value:										*/
//*   sun's apparent longitude in degrees						*/
//***********************************************************************/
	// 计算太阳的视经度。
	function calcSunApparentLong(t)
	{
		var o = calcSunTrueLong(t);

		var omega = 125.04 - 1934.136 * t;
		var lambda = o - 0.00569 - 0.00478 * Math.sin(degToRad(omega));
		return lambda;		// in degrees
	}

//***********************************************************************/
//* Name:    calcMeanObliquityOfEcliptic						*/
//* Type:    Function									*/
//* Purpose: calculate the mean obliquity of the ecliptic			*/
//* Arguments:										*/
//*   t : number of Julian centuries since J2000.0				*/
//* Return value:										*/
//*   mean obliquity in degrees							*/
//***********************************************************************/

	// 计算黄道的平均倾斜度。
	function calcMeanObliquityOfEcliptic(t)
	{
		var seconds = 21.448 - t*(46.8150 + t*(0.00059 - t*(0.001813)));
		var e0 = 23.0 + (26.0 + (seconds/60.0))/60.0;
		return e0;		// in degrees
	}

//***********************************************************************/
//* Name:    calcObliquityCorrection						*/
//* Type:    Function									*/
//* Purpose: calculate the corrected obliquity of the ecliptic		*/
//* Arguments:										*/
//*   t : number of Julian centuries since J2000.0				*/
//* Return value:										*/
//*   corrected obliquity in degrees						*/
//***********************************************************************/
	// 计算黄道的修正倾斜度。
	function calcObliquityCorrection(t)
	{
		var e0 = calcMeanObliquityOfEcliptic(t);

		var omega = 125.04 - 1934.136 * t;
		var e = e0 + 0.00256 * Math.cos(degToRad(omega));
		return e;		// in degrees
	}

//***********************************************************************/
//* Name:    calcSunRtAscension							*/
//* Type:    Function									*/
//* Purpose: calculate the right ascension of the sun				*/
//* Arguments:										*/
//*   t : number of Julian centuries since J2000.0				*/
//* Return value:										*/
//*   sun's right ascension in degrees						*/
//***********************************************************************/

	// 计算太阳的赤经。
	function calcSunRtAscension(t)
	{
		var e = calcObliquityCorrection(t);
		var lambda = calcSunApparentLong(t);
 
		var tananum = (Math.cos(degToRad(e)) * Math.sin(degToRad(lambda)));
		var tanadenom = (Math.cos(degToRad(lambda)));
		var alpha = radToDeg(Math.atan2(tananum, tanadenom));
		return alpha;		// in degrees
	}

//***********************************************************************/
//* Name:    calcSunDeclination							*/
//* Type:    Function									*/
//* Purpose: calculate the declination of the sun				*/
//* Arguments:										*/
//*   t : number of Julian centuries since J2000.0				*/
//* Return value:										*/
//*   sun's declination in degrees							*/
//***********************************************************************/
	// 计算太阳偏角。
	function calcSunDeclination(t)
	{
		var e = calcObliquityCorrection(t);
		var lambda = calcSunApparentLong(t);

		var sint = Math.sin(degToRad(e)) * Math.sin(degToRad(lambda));
		var theta = radToDeg(Math.asin(sint));
		return theta;		// in degrees
	}

//***********************************************************************/
//* Name:    calcEquationOfTime							*/
//* Type:    Function									*/
//* Purpose: calculate the difference between true solar time and mean	*/
//*		solar time									*/
//* Arguments:										*/
//*   t : number of Julian centuries since J2000.0				*/
//* Return value:										*/
//*   equation of time in minutes of time						*/
//***********************************************************************/

	// 计算真太阳时和平太阳时之间的差。
	function calcEquationOfTime(t)
	{
		var epsilon = calcObliquityCorrection(t);
		var l0 = calcGeomMeanLongSun(t);
		var e = calcEccentricityEarthOrbit(t);
		var m = calcGeomMeanAnomalySun(t);

		var y = Math.tan(degToRad(epsilon)/2.0);
		y *= y;

		var sin2l0 = Math.sin(2.0 * degToRad(l0));
		var sinm   = Math.sin(degToRad(m));
		var cos2l0 = Math.cos(2.0 * degToRad(l0));
		var sin4l0 = Math.sin(4.0 * degToRad(l0));
		var sin2m  = Math.sin(2.0 * degToRad(m));

		var Etime = y * sin2l0 - 2.0 * e * sinm + 4.0 * e * y * sinm * cos2l0
				- 0.5 * y * y * sin4l0 - 1.25 * e * e * sin2m;

		return radToDeg(Etime)*4.0;	// in minutes of time
	}

//***********************************************************************/
//* Name:    calcHourAngleSunrise							*/
//* Type:    Function									*/
//* Purpose: calculate the hour angle of the sun at sunrise for the	*/
//*			latitude								*/
//* Arguments:										*/
//*   lat : latitude of observer in degrees					*/
//*	solarDec : declination angle of sun in degrees				*/
//* Return value:										*/
//*   hour angle of sunrise in radians						*/
//***********************************************************************/

	// 计算日出时太阳时角。
	function calcHourAngleSunrise(lat, solarDec)
	{
		var latRad = degToRad(lat);
		var sdRad  = degToRad(solarDec)

		var HAarg = (Math.cos(degToRad(90.833))/(Math.cos(latRad)*Math.cos(sdRad))-Math.tan(latRad) * Math.tan(sdRad));

		var HA = (Math.acos(Math.cos(degToRad(90.833))/(Math.cos(latRad)*Math.cos(sdRad))-Math.tan(latRad) * Math.tan(sdRad)));

		return HA;		// in radians
	}

//***********************************************************************/
//* Name:    calcHourAngleSunset							*/
//* Type:    Function									*/
//* Purpose: calculate the hour angle of the sun at sunset for the	*/
//*			latitude								*/
//* Arguments:										*/
//*   lat : latitude of observer in degrees					*/
//*	solarDec : declination angle of sun in degrees				*/
//* Return value:										*/
//*   hour angle of sunset in radians						*/
//***********************************************************************/
	// 计算落时太阳时角。	
	function calcHourAngleSunset(lat, solarDec)
	{
		var latRad = degToRad(lat);
		var sdRad  = degToRad(solarDec)

		var HAarg = (Math.cos(degToRad(90.833))/(Math.cos(latRad)*Math.cos(sdRad))-Math.tan(latRad) * Math.tan(sdRad));

		var HA = (Math.acos(Math.cos(degToRad(90.833))/(Math.cos(latRad)*Math.cos(sdRad))-Math.tan(latRad) * Math.tan(sdRad)));

		return -HA;		// in radians
	}


//***********************************************************************/
//* Name:    calcSunriseUTC								*/
//* Type:    Function									*/
//* Purpose: calculate the Universal Coordinated Time (UTC) of sunrise	*/
//*			for the given day at the given location on earth	*/
//* Arguments:										*/
//*   JD  : julian day									*/
//*   latitude : latitude of observer in degrees				*/
//*   longitude : longitude of observer in degrees				*/
//* Return value:										*/
//*   time in minutes from zero Z							*/
//***********************************************************************/

	// 计算地球上特定位置特定日太阳升起的UTC时间。
	function calcSunriseUTC(JD, latitude, longitude)
	{
		var t = calcTimeJulianCent(JD);

		// *** Find the time of solar noon at the location, and use
        //     that declination. This is better than start of the 
        //     Julian day

		var noonmin = calcSolNoonUTC(t, longitude);
		var tnoon = calcTimeJulianCent (JD+noonmin/1440.0);

		// *** First pass to approximate sunrise (using solar noon)

		var eqTime = calcEquationOfTime(tnoon);
		var solarDec = calcSunDeclination(tnoon);
		var hourAngle = calcHourAngleSunrise(latitude, solarDec);

		var delta = longitude - radToDeg(hourAngle);
		var timeDiff = 4 * delta;	// in minutes of time
		var timeUTC = 720 + timeDiff - eqTime;	// in minutes

		// alert("eqTime = " + eqTime + "\nsolarDec = " + solarDec + "\ntimeUTC = " + timeUTC);

		// *** Second pass includes fractional jday in gamma calc

		var newt = calcTimeJulianCent(calcJDFromJulianCent(t) + timeUTC/1440.0); 
		eqTime = calcEquationOfTime(newt);
		solarDec = calcSunDeclination(newt);
		hourAngle = calcHourAngleSunrise(latitude, solarDec);
		delta = longitude - radToDeg(hourAngle);
		timeDiff = 4 * delta;
		timeUTC = 720 + timeDiff - eqTime; // in minutes

		// alert("eqTime = " + eqTime + "\nsolarDec = " + solarDec + "\ntimeUTC = " + timeUTC);

		return timeUTC;
	}

//***********************************************************************/
//* Name:    calcSolNoonUTC								*/
//* Type:    Function									*/
//* Purpose: calculate the Universal Coordinated Time (UTC) of solar	*/
//*		noon for the given day at the given location on earth		*/
//* Arguments:										*/
//*   t : number of Julian centuries since J2000.0				*/
//*   longitude : longitude of observer in degrees				*/
//* Return value:										*/
//*   time in minutes from zero Z							*/
//***********************************************************************/
	// 计算地球上特定位置特定日的视中午UTC时间。
	function calcSolNoonUTC(t, longitude)
	{
		// First pass uses approximate solar noon to calculate eqtime
		var tnoon = calcTimeJulianCent(calcJDFromJulianCent(t) + longitude/360.0);
		var eqTime = calcEquationOfTime(tnoon);
		var solNoonUTC = 720 + (longitude * 4) - eqTime; // min

		var newt = calcTimeJulianCent(calcJDFromJulianCent(t) -0.5 + solNoonUTC/1440.0); 

		eqTime = calcEquationOfTime(newt);
		// var solarNoonDec = calcSunDeclination(newt);
		solNoonUTC = 720 + (longitude * 4) - eqTime; // min
		
		return solNoonUTC;
	}

//***********************************************************************/
//* Name:    calcSunsetUTC								*/
//* Type:    Function									*/
//* Purpose: calculate the Universal Coordinated Time (UTC) of sunset	*/
//*			for the given day at the given location on earth	*/
//* Arguments:										*/
//*   JD  : julian day									*/
//*   latitude : latitude of observer in degrees				*/
//*   longitude : longitude of observer in degrees				*/
//* Return value:										*/
//*   time in minutes from zero Z							*/
//***********************************************************************/

	// 计算地球上特定位置特定日太阳落下的UTC时间。
	function calcSunsetUTC(JD, latitude, longitude)
	{
		var t = calcTimeJulianCent(JD);

		// *** Find the time of solar noon at the location, and use
        //     that declination. This is better than start of the 
        //     Julian day

		var noonmin = calcSolNoonUTC(t, longitude);
		var tnoon = calcTimeJulianCent (JD+noonmin/1440.0);

		// First calculates sunrise and approx length of day

		var eqTime = calcEquationOfTime(tnoon);
		var solarDec = calcSunDeclination(tnoon);
		var hourAngle = calcHourAngleSunset(latitude, solarDec);

		var delta = longitude - radToDeg(hourAngle);
		var timeDiff = 4 * delta;
		var timeUTC = 720 + timeDiff - eqTime;

		// first pass used to include fractional day in gamma calc

		var newt = calcTimeJulianCent(calcJDFromJulianCent(t) + timeUTC/1440.0); 
		eqTime = calcEquationOfTime(newt);
		solarDec = calcSunDeclination(newt);
		hourAngle = calcHourAngleSunset(latitude, solarDec);

		delta = longitude - radToDeg(hourAngle);
		timeDiff = 4 * delta;
		timeUTC = 720 + timeDiff - eqTime; // in minutes

		return timeUTC;
	}


//*********************************************************************/

// Returns the decimal latitude from the degrees, minutes and seconds entered 
// into the form	

	// 根据表单输入的度数、分、秒获取十进制的纬度。
	function getLatitude(latLongForm)
	{
		var neg = 0;
		var strLatDeg = latLongForm["latDeg"].value;
		var degs = parseFloat(latLongForm["latDeg"].value);
		if (latLongForm["latDeg"].value.charAt(0) == '-') 
		{
			neg = 1;
		}

		if (strLatDeg.indexOf(".") != -1) 
		{
			latLongForm["latMin"].value = 0;
			latLongForm["latSec"].value = 0;
		}

		if(latLongForm["latMin"].value == "")
		{
			latLongForm["latMin"].value = 0;
		}
		if(latLongForm["latSec"].value == "")
		{
			latLongForm["latSec"].value = 0;
		}

		var mins = parseFloat(latLongForm["latMin"].value);

		var secs = parseFloat(latLongForm["latSec"].value);

		if(neg != 1)
		{
			var decLat = degs + (mins / 60) + (secs / 3600);
		} else if(neg == 1)
		{
			var decLat = degs - (mins / 60) - (secs / 3600);
		} else 
		{
			return -9999;
		}
		return decLat;
	}	


//*********************************************************************/

// Returns the decimal longitude from the degrees, minutes and seconds entered into the form	
	// 根据表单输入的度、分、秒获取十进制的经度。
	function getLongitude(latLongForm)
	{
		var neg = 0;
		var strLonDeg = latLongForm["lonDeg"].value;
		var degs = parseFloat(latLongForm["lonDeg"].value);
		if (latLongForm["lonDeg"].value.charAt(0) == '-') 
		{
			neg = 1;
		}

		if (strLonDeg.indexOf(".") != -1) 
		{
			latLongForm["lonMin"].value = 0;
			latLongForm["lonSec"].value = 0;
		}

		if(latLongForm["lonMin"].value == "")
		{
			latLongForm["lonMin"].value = 0;
		}
		if(latLongForm["lonSec"].value == "")
		{
			latLongForm["lonSec"].value = 0;
		}

		var mins = parseFloat(latLongForm["lonMin"].value);
		var secs = parseFloat(latLongForm["lonSec"].value);
		var decLon = degs + (mins / 60) + (secs / 3600);

		if(neg != 1)
		{
			var decLon = degs + (mins / 60) + (secs / 3600);
		} else if(neg == 1)
		{
			var decLon = degs - (mins / 60) - (secs / 3600);
		} else 
		{
			return -9999;
		}
		return decLon;
	}	


//***********************************************************************/
//* Name:    findRecentSunrise							*/
//* Type:    Function									*/
//* Purpose: calculate the julian day of the most recent sunrise		*/
//*		starting from the given day at the given location on earth	*/
//* Arguments:										*/
//*   JD  : julian day									*/
//*   latitude : latitude of observer in degrees				*/
//*   longitude : longitude of observer in degrees				*/
//* Return value:										*/
//*   julian day of the most recent sunrise					*/
//***********************************************************************/
	// 搜寻地球上特定位置给定日期以来最近的日出儒略日。
	function findRecentSunrise(jd, latitude, longitude)
	{
		var julianday = jd;

		var time = calcSunriseUTC(julianday, latitude, longitude);
		while(!isNumber(time)){
			julianday -= 1.0;
			time = calcSunriseUTC(julianday, latitude, longitude);
		}

		return julianday;
	}


//***********************************************************************/
//* Name:    findRecentSunset								*/
//* Type:    Function									*/
//* Purpose: calculate the julian day of the most recent sunset		*/
//*		starting from the given day at the given location on earth	*/
//* Arguments:										*/
//*   JD  : julian day									*/
//*   latitude : latitude of observer in degrees				*/
//*   longitude : longitude of observer in degrees				*/
//* Return value:										*/
//*   julian day of the most recent sunset					*/
//***********************************************************************/
	// 搜寻地球上特定位置给定日期以来最近的日落儒略日。
	function findRecentSunset(jd, latitude, longitude)
	{
		var julianday = jd;

		var time = calcSunsetUTC(julianday, latitude, longitude);
		while(!isNumber(time)){
			julianday -= 1.0;
			time = calcSunsetUTC(julianday, latitude, longitude);
		}

		return julianday;
	}


//***********************************************************************/
//* Name:    findNextSunrise								*/
//* Type:    Function									*/
//* Purpose: calculate the julian day of the next sunrise			*/
//*		starting from the given day at the given location on earth	*/
//* Arguments:										*/
//*   JD  : julian day									*/
//*   latitude : latitude of observer in degrees				*/
//*   longitude : longitude of observer in degrees				*/
//* Return value:										*/
//*   julian day of the next sunrise						*/
//***********************************************************************/
	// 搜寻地球上特定位置给定日期以来下一个的日出儒略日。
	function findNextSunrise(jd, latitude, longitude)
	{
		var julianday = jd;

		var time = calcSunriseUTC(julianday, latitude, longitude);
		while(!isNumber(time)){
			julianday += 1.0;
			time = calcSunriseUTC(julianday, latitude, longitude);
		}

		return julianday;
	}


//***********************************************************************/
//* Name:    findNextSunset								*/
//* Type:    Function									*/
//* Purpose: calculate the julian day of the next sunset			*/
//*		starting from the given day at the given location on earth	*/
//* Arguments:										*/
//*   JD  : julian day									*/
//*   latitude : latitude of observer in degrees				*/
//*   longitude : longitude of observer in degrees				*/
//* Return value:										*/
//*   julian day of the next sunset							*/
//***********************************************************************/
	// 搜寻地球上特定位置给定日期以来下一个的日落儒略日。
	function findNextSunset(jd, latitude, longitude)
	{
		var julianday = jd;

		var time = calcSunsetUTC(julianday, latitude, longitude);
		while(!isNumber(time)){
			julianday += 1.0;
			time = calcSunsetUTC(julianday, latitude, longitude);
		}

		return julianday;
	}

//***********************************************************************/
//* Name:    timeString									*/
//* Type:    Function									*/
//* Purpose: convert time of day in minutes to a zero-padded string suitable for printing to the form text fields			*/
//* Arguments:										*/
//*   minutes : time of day in minutes						*/
//* Return value:										*/
//*   string of the format HH:MM:SS, minutes and seconds are zero padded*/
//***********************************************************************/
	// 将分钟转换成HH:MM:SS格式。
	function timeString(minutes)
	// timeString returns a zero-padded string (HH:MM:SS) given time in minutes
	{
		var floatHour = minutes / 60.0;
		var hour = Math.floor(floatHour);
		var floatMinute = 60.0 * (floatHour - Math.floor(floatHour));
		var minute = Math.floor(floatMinute);
		var floatSec = 60.0 * (floatMinute - Math.floor(floatMinute));
		var second = Math.floor(floatSec + 0.5);

		var timeStr = hour + ":";
		if (minute < 10)	//	i.e. only one digit
			timeStr += "0" + minute + ":";
		else
			timeStr += minute + ":";
		if (second < 10)	//	i.e. only one digit
			timeStr += "0" + second;
		else
			timeStr += second;

		return timeStr;
	}


//***********************************************************************/
//* Name:    timeStringShortAMPM							*/
//* Type:    Function									*/
//* Purpose: convert time of day in minutes to a zero-padded string	*/
//*		suitable for printing to the form text fields.  If time	*/
//*		crosses a day boundary, date is appended.				*/
//* Arguments:										*/
//*   minutes : time of day in minutes						*/
//*   JD  : julian day									*/
//* Return value:										*/
//*   string of the format HH:MM[AM/PM] (DDMon)					*/
//***********************************************************************/

// timeStringShortAMPM returns a zero-padded string (HH:MM *M) given time in 
// minutes and appends short date if time is > 24 or < 0, resp.
	// 将分钟转换成HH:MM[AM/PM]格式。
	function timeStringShortAMPM(minutes, JD)
	{
		var julianday = JD;
		var floatHour = minutes / 60.0;
		var hour = Math.floor(floatHour);
		var floatMinute = 60.0 * (floatHour - Math.floor(floatHour));
		var minute = Math.floor(floatMinute);
		var floatSec = 60.0 * (floatMinute - Math.floor(floatMinute));
		var second = Math.floor(floatSec + 0.5);
		var PM = false;

		minute += (second >= 30)? 1 : 0;

		if (minute >= 60) 
		{
			minute -= 60;
			hour ++;
		}

		var daychange = false;
		if (hour > 23) 
		{
			hour -= 24;
			daychange = true;
			julianday += 1.0;
		}

		if (hour < 0)
		{
			hour += 24;
			daychange = true;
			julianday -= 1.0;
		}

		if (hour > 12)
		{
			hour -= 12;
			PM = true;
		}

            if (hour == 12)
		{
              PM = true;
            }

		if (hour == 0)
		{
			PM = false;
			hour = 12;
		}

		var timeStr = hour + ":";
		if (minute < 10)	//	i.e. only one digit
			timeStr += "0" + minute + ((PM)?"PM":"AM");
		else
			timeStr += "" + minute + ((PM)?"PM":"AM");

		if (daychange) return timeStr + " " + calcDayFromJD(julianday);
		return timeStr;
	}


//***********************************************************************/
//* Name:    timeStringAMPMDate							*/
//* Type:    Function									*/
//* Purpose: convert time of day in minutes to a zero-padded string	*/
//*		suitable for printing to the form text fields, and appends	*/
//*		the date.									*/
//* Arguments:										*/
//*   minutes : time of day in minutes						*/
//*   JD  : julian day									*/
//* Return value:										*/
//*   string of the format HH:MM[AM/PM] DDMon					*/
//***********************************************************************/

// timeStringAMPMDate returns a zero-padded string (HH:MM[AM/PM]) given time 
// in minutes and julian day, and appends the short date

	// 将分钟转换成HH:MM[AM/PM]格式。
	function timeStringAMPMDate(minutes, JD)
	{
		var julianday = JD;
		var floatHour = minutes / 60.0;
		var hour = Math.floor(floatHour);
		var floatMinute = 60.0 * (floatHour - Math.floor(floatHour));
		var minute = Math.floor(floatMinute);
		var floatSec = 60.0 * (floatMinute - Math.floor(floatMinute));
		var second = Math.floor(floatSec + 0.5);

		minute += (second >= 30)? 1 : 0;

		if (minute >= 60) 
		{
			minute -= 60;
			hour ++;
		}

		if (hour > 23) 
		{
			hour -= 24;
			julianday += 1.0;
		}

		if (hour < 0)
		{
			hour += 24;
			julianday -= 1.0;
		}

		var PM = false;
		if (hour > 12)
		{
			hour -= 12;
			PM = true;
		}

        if (hour == 12)
		{
            PM = true;
        }

		if (hour == 0)
		{
			PM = false;
			hour = 12;
		}

		var timeStr = hour + ":";
		if (minute < 10)	//	i.e. only one digit
			timeStr += "0" + minute + ((PM)?"PM":"AM");
		else
			timeStr += minute + ((PM)?"PM":"AM");

		return timeStr + " " + calcDayFromJD(julianday);
	}


//***********************************************************************/
//* Name:    timeStringDate								*/
//* Type:    Function									*/
//* Purpose: convert time of day in minutes to a zero-padded 24hr time	*/
//*		suitable for printing to the form text fields.  If time	*/
//*		crosses a day boundary, date is appended.				*/
//* Arguments:										*/
//*   minutes : time of day in minutes						*/
//*   JD  : julian day									*/
//* Return value:										*/
//*   string of the format HH:MM (DDMon)						*/
//***********************************************************************/

// timeStringDate returns a zero-padded string (HH:MM) given time in minutes
// and julian day, and appends the short date if time crosses a day boundary

	// 将分钟转换成HH:MM格式的24小时。
	function timeStringDate(minutes, JD)
	{
		var julianday = JD;
		var floatHour = minutes / 60.0;
		var hour = Math.floor(floatHour);
		var floatMinute = 60.0 * (floatHour - Math.floor(floatHour));
		var minute = Math.floor(floatMinute);
		var floatSec = 60.0 * (floatMinute - Math.floor(floatMinute));
		var second = Math.floor(floatSec + 0.5);

		minute += (second >= 30)? 1 : 0;

		if (minute >= 60) 
		{
			minute -= 60;
			hour ++;
		}

		var daychange = false;
		if (hour > 23) 
		{
			hour -= 24;
			julianday += 1.0;
			daychange = true;
		}

		if (hour < 0)
		{
			hour += 24;
			julianday -= 1.0;
			daychange = true;
		}

		var timeStr = hour + ":";
		if (minute < 10)	//	i.e. only one digit
			timeStr += "0" + minute;
		else
			timeStr += minute;

		if (daychange) return timeStr + " " + calcDayFromJD(julianday);
		return timeStr;
	}

	
//***********************************************************************/
//* Name:    calcSun									*/
//* Type:    Main Function called by form controls				*/
//* Purpose: calculate time of sunrise and sunset for the entered date	*/
//*		and location.  In the special cases near earth's poles, 	*/
//*		the date of nearest sunrise and set are reported.		*/
//* Arguments:										*/
//*   riseSetForm : for displaying results					*/
//*   latLongForm : for reading latitude and longitude data			*/
//*   index : daylight saving yes/no select					*/
//*   index2 : city select index							*/
//* Return value:										*/
//*   none											*/
//*	(fills riseSetForm text fields with results of calculations)	*/
//***********************************************************************/

	// 计算表单中输入的日期和位置的日出日落的时间。
	function calcSun(riseSetForm, latLongForm, index, index2) 
	{
		if(index2 != 0)
		{
			setLatLong(latLongForm, index2);
		}

		var latitude = getLatitude(latLongForm);
		var longitude = getLongitude(latLongForm);
		var indexRS = riseSetForm.mos.selectedIndex
		if (isValidInput(riseSetForm, indexRS, latLongForm)) 
		{
			if((latitude >= -90) && (latitude < -89))
			{
				alert("All latitudes between 89 and 90 S\n will be set to -89");
				latLongForm["latDeg"].value = -89;
				latitude = -89;
			}
			if ((latitude <= 90) && (latitude > 89))
			{
				alert("All latitudes between 89 and 90 N\n will be set to 89");
				latLongForm["latDeg"].value = 89;
				latitude = 89;
			}
			
			//*****	Calculate the time of sunrise			

//*********************************************************************/
//****************   NEW STUFF   ******   一月, 2001   ****************
//*********************************************************************/

			var JD = calcJD(parseFloat(riseSetForm["year"].value), indexRS + 1, parseFloat(riseSetForm["day"].value));
			var dow = calcDayOfWeek(JD);
			var doy = calcDayOfYear(indexRS + 1, parseFloat(riseSetForm["day"].value), isLeapYear(riseSetForm["year"].value));
			var T = calcTimeJulianCent(JD);

			var alpha = calcSunRtAscension(T);
			var theta = calcSunDeclination(T);
			var Etime = calcEquationOfTime(T);

			//riseSetForm["dbug"].value = doy;

//*********************************************************************/

			var eqTime = Etime;
			var solarDec = theta;

			// Calculate sunrise for this date
			// if no sunrise is found, set flag nosunrise

			var nosunrise = false;

			var riseTimeGMT = calcSunriseUTC(JD, latitude, longitude);
			if (!isNumber(riseTimeGMT))
			{
				nosunrise = true;
			}

			// Calculate sunset for this date
			// if no sunset is found, set flag nosunset

			var nosunset = false;
			var setTimeGMT = calcSunsetUTC(JD, latitude, longitude);
			if (!isNumber(setTimeGMT))
			{
				nosunset = true;
			}

			var daySavings = YesNo[index].value;  // = 0 (no) or 60 (yes)
			var zone = latLongForm["hrsToGMT"].value;
			if(zone > 12 || zone < -12.5)
			{
				alert("The offset must be between -12.5 and 12.  \n Setting \"Off-Set\"=0");
				zone = "0";
				latLongForm["hrsToGMT"].value = zone;
			}

			if (!nosunrise)		// Sunrise was found
			{
				var riseTimeLST = riseTimeGMT - (60 * zone) + daySavings;	
					//	in minutes
				var riseStr = timeStringShortAMPM(riseTimeLST, JD);
				var utcRiseStr = timeStringDate(riseTimeGMT, JD);

				riseSetForm["sunrise"].value = riseStr;
				riseSetForm["utcsunrise"].value = utcRiseStr;
			}

			if (!nosunset)		// Sunset was found
			{
				var setTimeLST = setTimeGMT - (60 * zone) + daySavings;
				var setStr = timeStringShortAMPM(setTimeLST, JD);
				var utcSetStr = timeStringDate(setTimeGMT, JD);

				riseSetForm["sunset"].value = setStr;
				riseSetForm["utcsunset"].value = utcSetStr;
			}

			// Calculate solar noon for this date

			var solNoonGMT = calcSolNoonUTC(T, longitude);
			var solNoonLST = solNoonGMT - (60 * zone) + daySavings;

			var solnStr = timeString(solNoonLST);
			var utcSolnStr = timeString(solNoonGMT);

			riseSetForm["solnoon"].value = solnStr;
			riseSetForm["utcsolnoon"].value = utcSolnStr;

			var tsnoon = calcTimeJulianCent(calcJDFromJulianCent(T) -0.5 + solNoonGMT/1440.0); 

			eqTime = calcEquationOfTime(tsnoon);
			solarDec = calcSunDeclination(tsnoon);

			riseSetForm["eqTime"].value = (Math.floor(100*eqTime))/100;
			riseSetForm["solarDec"].value = (Math.floor(100*(solarDec)))/100;
			
			//***********Convert lat and long to standard format
			convLatLong(latLongForm);

			// report special cases of no sunrise

			if(nosunrise)
			{ 
				riseSetForm["utcsunrise"].value = "";
				// if Northern hemisphere and spring or summer, OR  
				// if Southern hemisphere and fall or winter, use 
				// previous sunrise and next sunset

				if ( ((latitude > 66.4) && (doy > 79) && (doy < 267)) ||
				   ((latitude < -66.4) && ((doy < 83) || (doy > 263))) )
				{
					newjd = findRecentSunrise(JD, latitude, longitude);
					newtime = calcSunriseUTC(newjd, latitude, longitude)
						 - (60 * zone) + daySavings;
					if (newtime > 1440)
					{
						newtime -= 1440;
						newjd += 1.0;
					}
					if (newtime < 0)
					{
						newtime += 1440;
						newjd -= 1.0;
					}
					riseSetForm["sunrise"].value = 
						timeStringAMPMDate(newtime, newjd);
					riseSetForm["utcsunrise"].value = "prior sunrise";
				}

				// if Northern hemisphere and fall or winter, OR 
				// if Southern hemisphere and spring or summer, use 
				// next sunrise and previous sunset

				else if ( ((latitude > 66.4) && ((doy < 83) || (doy > 263))) ||
					((latitude < -66.4) && (doy > 79) && (doy < 267)) )
				{
					newjd = findNextSunrise(JD, latitude, longitude);
					newtime = calcSunriseUTC(newjd, latitude, longitude)
						 - (60 * zone) + daySavings;
					if (newtime > 1440)
					{
						newtime -= 1440;
						newjd += 1.0;
					}
					if (newtime < 0)
					{
						newtime += 1440;
						newjd -= 1.0;
					}
					riseSetForm["sunrise"].value = 
						timeStringAMPMDate(newtime, newjd);
//					riseSetForm["sunrise"].value = calcDayFromJD(newjd)
//						+ " " + timeStringDate(newtime, newjd);
					riseSetForm["utcsunrise"].value = "next sunrise";
				}
				else 
				{
					alert("Cannot Find Sunrise!");
				}

				// alert("Last Sunrise was on day " + findRecentSunrise(JD, latitude, longitude));
				// alert("Next Sunrise will be on day " + findNextSunrise(JD, latitude, longitude));

			}

			if(nosunset)
			{ 
				riseSetForm["utcsunset"].value = "";
				// if Northern hemisphere and spring or summer, OR
				// if Southern hemisphere and fall or winter, use 
				// previous sunrise and next sunset

				if ( ((latitude > 66.4) && (doy > 79) && (doy < 267)) ||
				   ((latitude < -66.4) && ((doy < 83) || (doy > 263))) )
				{
					newjd = findNextSunset(JD, latitude, longitude);
					newtime = calcSunsetUTC(newjd, latitude, longitude)
						 - (60 * zone) + daySavings;
					if (newtime > 1440)
					{
						newtime -= 1440;
						newjd += 1.0;
					}
					if (newtime < 0)
					{
						newtime += 1440;
						newjd -= 1.0;
					}
					riseSetForm["sunset"].value = 
						timeStringAMPMDate(newtime, newjd);
					riseSetForm["utcsunset"].value = "next sunset";
					riseSetForm["utcsolnoon"].value = "";
				}

				// if Northern hemisphere and fall or winter, OR
				// if Southern hemisphere and spring or summer, use 
				// next sunrise and last sunset

				else if ( ((latitude > 66.4) && ((doy < 83) || (doy > 263))) ||
					((latitude < -66.4) && (doy > 79) && (doy < 267)) )
				{
					newjd = findRecentSunset(JD, latitude, longitude);
					newtime = calcSunsetUTC(newjd, latitude, longitude)
						 - (60 * zone) + daySavings;
					if (newtime > 1440)
					{
						newtime -= 1440;
						newjd += 1.0;
					}
					if (newtime < 0)
					{
						newtime += 1440;
						newjd -= 1.0;
					}
					riseSetForm["sunset"].value = 
						timeStringAMPMDate(newtime, newjd);
					riseSetForm["utcsunset"].value = "prior sunset";
					riseSetForm["solnoon"].value = "N/A";
					riseSetForm["utcsolnoon"].value = "";
				}

				else 
				{
					alert ("Cannot Find Sunset!");
				}
			}
		}
	}



//*********************************************************************/



</SCRIPT>

<FORM NAME="cityLatLong">
	<CENTER><TABLE BORDER>
	<TR>
		<TD ALIGN="CENTER"><H9>城市</TD>
		<TD></TD>
		<TD ALIGN="CENTER"><H9>度</TD>

		<TD ALIGN="CENTER"><H9>分</TD>

		<TD ALIGN="CENTER"><H9>秒</TD>
		<TD ALIGN="CENTER" COLSPAN="5"><H9><a href="./timezone.html">时区</TD>
</TR>

<TR>
<TD ALIGN="TOP">
<CENTER>
<SELECT NAME="cities" onChange="calcSun(riseSetCalc, cityLatLong, cityLatLong.dayAns.selectedIndex, cityLatLong.cities.selectedIndex);">

	    		<SCRIPT LANGUAGE="JavaScript">
	    		for (i = 0; i < City.length; i++) {
				if(City[i].name == "北京, 中国")
				{
				document.writeln("<OPTION SELECTED>" + City[i].name);
	    		}
				else
				document.writeln("<OPTION>" + City[i].name);
				} 

				</SCRIPT>

	  		</SELECT>
</CENTER>
</TD>
		<TD ALIGN="CENTER"><H5><a href="./glossary.html#latitude">纬度</a>:<BR>北=+<BR>南=<FONT SIZE = 4>-</FONT></TD>

		<TD><INPUT TYPE="text" NAME="latDeg" VALUE="39" SIZE="4"></TD>

		<TD><INPUT TYPE="text" NAME="latMin" VALUE="54" SIZE="4"></TD>

		<TD><INPUT TYPE="text" NAME="latSec" VALUE="00" SIZE="4"></TD>
		<TD ROWSPAN=2 ALIGN="CENTER"><H5>时差距 
			<a href="./glossary.html#UTC">UTC</a><BR>(BST=-8)<BR></H5>
		<INPUT TYPE="text" NAME="hrsToGMT" VALUE="-8" SIZE="5"></TD>
		<TD ROWSPAN=2 ALIGN = "CENTER"><H6><a href="./glossary.html#daylightsavingtime">夏令时</a><BR></H5>
		<SELECT NAME="dayAns" onChange="calcSun(riseSetCalc, cityLatLong, cityLatLong.dayAns.selectedIndex, cityLatLong.cities.selectedIndex);">
	<SCRIPT LANGUAGE="JavaScript">
		for(i=0; i < YesNo.length; i++)
		{
			document.writeln("<OPTION>" + YesNo[i].daySave);
		}
	</SCRIPT>
		</SELECT>

		</TD>
	</TR>
<TR>
 		<TD ALIGN="CENTER"><H3><a href="http://samuel.lamost.org/guide/jwd.htm">点击查找你所要位置的经纬度</a>
		</TD>


		<TD ALIGN="CENTER"><H5><a href="./glossary.html#longitude">经度</a>:<BR>西=+<BR>东=<FONT SIZE = 4>-</FONT></TD>

		<TD><INPUT TYPE="text" NAME="lonDeg" VALUE="116" SIZE="4"></TD>

		<TD><INPUT TYPE="text" NAME="lonMin" VALUE="28" SIZE="4"></TD>

		<TD><INPUT TYPE="text" NAME="lonSec" VALUE="00" SIZE="4"></TD>

	</TR>
	<TR>
	<TD COLSPAN=7>
<b>注:</b>  手动输入经纬度时,在城市下拉菜单中选择 <b>输入经纬度-></b> ,在右边对应的数据输入框内输入数据。
	</TD></TR>

	</TABLE>
</CENTER>
</FORM>



<FORM NAME="riseSetCalc">
	<CENTER><TABLE BORDER>

	<TR>

	  	<TD ALIGN="CENTER"><H9>月</TD>

		<TD ALIGN="CENTER"><H9>日</TD>

		<TD ALIGN="CENTER"><H9>年 (4位数):</TD>




	</TR>

	<TR>

	  	<TD>

			<SELECT NAME="mos" onChange="calcSun(riseSetCalc, cityLatLong, cityLatLong.dayAns.selectedIndex, cityLatLong.cities.selectedIndex);">

  	<SCRIPT LANGUAGE="JavaScript">
		dateObj1 = new Date();
		thismonth = dateObj1.getMonth();
		today = dateObj1.getDate(); 
		for (i = 0; i < monthList.length; i++) 
		{
			if (i == thismonth) 
			{
				document.writeln("<OPTION SELECTED>" + monthList[i].name);
			}
			else 
			{
				document.writeln("<OPTION>" + monthList[i].name);
			}
		}

	</SCRIPT>

	  		</SELECT>

	  	</TD>

	 <SCRIPT LANGUAGE="JavaScript">
		dateObj2 = new Date();
		thisday = dateObj2.getDate();
	  	
		document.writeln("<TD><CENTER><INPUT TYPE=\"text\" NAME=\"day\" SIZE=\"2\" VALUE=\"" + thisday + "\"></TD>");

		dateObj3 = new Date();
		thisYear = dateObj3.getYear();
		if(thisYear <=199)
		{
			thisYear=(thisYear*1)+1900;
		}
		document.writeln("<TD><CENTER><INPUT TYPE=\"text\" NAME=\"year\" SIZE=\"4\"VALUE=\"" + thisYear*1 + "\"></TD>");
	</SCRIPT>


	</TR>
</TABLE>

<BR>

	  	<INPUT TYPE="button" NAME="RiseSet" VALUE="     计算日出/日没时间     " 

			onClick="calcSun(riseSetCalc, cityLatLong, cityLatLong.dayAns.selectedIndex, cityLatLong.cities.selectedIndex);">

<BR>

<BR>
<TABLE BORDER>
 	<TR>	
		<TD ALIGN="CENTER"><H9><a href="./glossary.html#equationoftime">时差</a><BR>(分)</TD>
		<TD ALIGN="CENTER"><H9><a href="./glossary.html#solardeclination">太阳赤纬</a><BR> (度)</TD>
		<TD ALIGN="CENTER"><H9><a href="./glossary.html#apparentsunrise">视日出</a> </TD>
		<TD ALIGN="CENTER"><H9><a href="./glossary.html#solarnoon">视中午</a></TD>
		<TD ALIGN="CENTER"><H9><a href="./glossary.html#apparentsunrise">视日没</a> </TD>
		<TD ALIGN="CENTER"><H9>时区</TD>	   		
	</TR>
	<TR>
		<TD><CENTER><INPUT TYPE="text" NAME="eqTime" SIZE = "8"></TD>
		<TD><CENTER><INPUT TYPE="text" NAME="solarDec" SIZE = "8"></TD>
		<TD><CENTER><INPUT TYPE="text" NAME="sunrise" SIZE="13"></TD>
		<TD><CENTER><INPUT TYPE="text" NAME="solnoon" SIZE="8"></TD>
		<TD><CENTER><INPUT TYPE="text" NAME="sunset" SIZE="13"></TD>
		<TD ALIGN="LEFT"><h9>地方标准时</TD>

	</TR>
    <TR>
		<TD ALIGN="CENTER" COLSPAN="2">
		<!-- <CENTER><INPUT TYPE="text" NAME="dbug" SIZE="15"> -->
		</TD>
		<TD><CENTER><INPUT TYPE="text" NAME="utcsunrise" SIZE="13"></TD>
		<TD><CENTER><INPUT TYPE="text" NAME="utcsolnoon" SIZE="8"></TD>
		<TD><CENTER><INPUT TYPE="text" NAME="utcsunset" SIZE="13"></TD>
		<TD ALIGN="CENTER"><H9>UTC</TD>
</CENTER></TR>
</TABLE>
</CENTER>
</FORM></FONT>

<HR>
<CENTER><P>
<B><H2>注释</b><BR><FONT SIZE=4>
</CENTER>
<OL>
<LI>
从城市下拉菜单中可以选择一个地方计算，<U>或</U> 选择<b>"输入经纬度 ->"</b> 
手动输入经纬度和时区信息到相应的栏目框内。注意经纬度正负转换。 
</P></FONT>

<P>
</CENTER><FONT SIZE=3>
经纬度输入可以是度/分/秒, 也可以在"度"栏内输入带小数点的度。
从下拉菜单中选择城市，可以自动添加经纬度和时区信息到相应栏目。 
手动输入经纬度和时区信息时， <u>一定要在城市下拉菜单项中选择"输入经纬度 -->"</u> 
否则, 你输入的数据将被原来选中的城市数据覆盖。
</P>
</LI>
<LI>
<P>
如果从城市下拉菜单中选择"输入经纬度 -->"，可以输入不同的时区信息。
否则，选中城市的地方标准时（Local Standard Time）对应的时区信息就会自动输入。  
在夏令时栏选择"是"将使得相应的日出、日没和正午时间推后一个小时。 
如果对所在地的时区信息不确定，可以参考
<a href="./timezone.html">时区表</a>. 
</P>
</LI>
<LI>
<P>
程序从计算机自动获取当前日期填入对应栏目内。 
要计算其它日期数值，只需要在月下拉菜单中输入相应数值，手动输入日和4位数的年份数值即可。
手动输入新的时期后，双击"计算日出日没时间"按钮更新输出结果。 
</P>
</LI>
<LI>
<P>
结果可以选择打印输出。
</P>
</LI>
<LI>
<P>
在极圈内的地方，日出日没不会发生时（极昼和极夜情形），结果显示的是最近某天的日出和日没时刻（前或后），
在 UTC栏内将显示 "prior" 或 "next" 信息。
</P>
</LI>
<LI>
<P>
在纬度大于 72 度的地区, 计算误差精度在10分钟内。
在纬度小于 +/- 72&deg的地区; 其精度大约为 1分钟。更多信息可以参考 <a href="./calcdetails.html">Solar Calculation 
Details</a> 。
</P>
</LI>
</OL>

</FONT>
<BR>
<HR>

<h4>
<table border=0 width="100%">
<tr>
<td align="left">
<a href="./sollinks.html">相关链接</a><br>
</td>

<td align="center">
<a href="http://linzhonghui.googlepages.com/"><img src="./igsnrr_02.jpg" border="0" alt="龙门山人"></a>
</td>

<td align="right">
<a href="/index.html">返回主页</a><br>
</td>
</tr>
</table>

</h4>

<center>by 
<a href="mailto:linzhonghui@Gmail.com;">龙门山人</a>
<br>
	<SCRIPT>
		document.write("Last Updated on " + document.lastModified + ".");
	</SCRIPT>
</center>

</BODY>
</HTML>

